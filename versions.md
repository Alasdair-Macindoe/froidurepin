# Introduction
Please refer to `data.md` for the input corresponding to each number.
Additionally to `runtimes.md` for the runtime of each version.  

# Running Example
For explanations consider the following semigroup over {a, b, c, d} which has [a, b] as generators and the following multiples:

```
aa = c
ab = a
ba = d
bb = a
ca = a
ac = a
cb = d
bc = d
da = b
db = a
ba = d
bd = a
```

Then let Y = the set of reduced words at a specific stage, and A = the generators for this semigroup.

Finally note that 'Concurren(t/cy) Processing Unit' is either a thread, process or task.

# Version 1 - One-Dimensional Array Data Structure with No Concurrency and Locking

In this version there is a one-dimensional array that holds the entire graph, and there are indexes stored that tell us the front and the end of the current frontier of the graph.

Using the running example we get A = [a, b]. After we initialise our data structure we get Y = [a, b] with our start = 1, and end = 2.

After we performing our multiplications to produce our Cayley table we add [c, d] this will give us Y = [a, b, c, d] with start = 3 and end = 4. This is where the calculations would end and our Y would contain a datastructure that allows us to create the graph. For example if we take Y[1] our data structure will include right[2] (this means Y[1] (a) times A[2] (b) which will give us a). In effect c and d are the forefront of our graph.

## Apply Generators

The queue generated by `ApplyGenerators` is a 2-D array (technically ApplyGenerators amends in place an already created 2-D array). Each bucket is given its own array inside the main array (hence making it 2-D) and each concurrent unit of processing gets its own bucket (thus there are as many buckets as there are concurrent processing) meaning that there is no need for locking here since there cannot be any problems.

If we consider at the start our Queue Q = [[], []] which will have two units of concurrency. At the end of Apply Generators. This could become: [ [c, d], [d]]. AT this point c, d are not values but full datastructures (although no left Cayley graph created at this point).

## Merge Queue

`MergeQueues` takes all the potentially new values from `ApplyGenerators` and merges them into our reduced words collection Y if they are new, and discards them otherwise.

If we have Y = [a, b] and our Queues Q = [ [c, d], [d]] then at the end of our this method our Y = [a, b, c, d].

## Develop Left

Takes the new Y produced from MergeQueues and creates the left Cayley graph for any values that needs them. Nothing exceptionally special. No multiplications happen at this stage.

## Jobs
For this version the standard number of jobs (effectively how many fragements we take) is one per generator.

# Version 1.1.x

All of these Versions will use a bucket per generator in ApplyGenerators output and will split fragment the known search space based upon two conditions: firstly how large our frontier is and how many jobs we have (which by default is the number of generators we are given).

## Version 1.1.1 - Tasks & Locking

This version is an extension of Version 1. It has concurrency introduced using
HPC-GAP's Task system and uses locking to allow us to maintain a 1-D array for our Y set (the set of reduced words). This is done using HPC-GAP's atomic types.

## Version 1.1.2 - Threads & Locking

This is the same as Version 1.1 but uses HPC-GAP's Threads instead of Tasks.

## Version 1.1.3 - Processes & Locking

This uses Processes instead of Tasks or Threads as in 1.1 and 1.2 respectively.  
